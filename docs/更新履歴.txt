
やねうら王 更新履歴

・pos.is_draw()実装する。
・MovePickerに他のオーダリングも導入
・lazy SMPで並列化して+R300程度かな？他の最適化してから考えよう。

■ 2016/02/21 V1.68

・nano plus、full depth searchも、nonPVでやるべきでは..
　→　修正した。
・LMRのreduction量、ONE_PLYを引いてからリダクションしないといけないの、間違えていたので修正。

	・V1.68a

・full depth searchで探索窓狭くしていなかったの修正。
	130ぐらい低いな…。わけがわからん…。

          Depth d = max(newDepth - r + (Depth)1, ONE_PLY);
	こうしたら、めっちゃ勝率上がった。わけがわからん…。


			77.9%	
			#20
			やねうら王nano plus V168
			LMR、full depth search修正,1スレッド、0.1秒設定
			#
			やねうら王nano plus V166
			通常探索でevaluate()を呼び出すように,1スレッド、0.1秒設定

			187-1-53(0.0% R219.0)	

	・V1.68b
          Depth d = max(newDepth - r , ONE_PLY);
		  こう戻してみる。

		37.1%	
		#21
		やねうら王nano plus V168b
		LMR変更テスト,1スレッド、0.1秒設定
		#
		やねうら王nano plus V166
		通常探索でevaluate()を呼び出すように,1スレッド、0.1秒設定

		109-3-185(100.0% R-91.9)	

		  →　やはり-R90ぐらいになる。わけがわからん。

	・V1.68c
		捕獲はreduction減らす。
		→　関係なさげ。
		reduction、0.5手延長のようになって強いだけなのか？

		一度、nanoと比較してみる。
		
		94.0%	
		#22
		やねうら王nano plus V168c
		LMR変更テスト2,1スレッド、0.1秒設定
		#1
		やねうら王nano V140
		やねうら王nanoの最終版1スレッド、0.1秒設定

		156-1-10(0.0% R477.2)	


		88.2%	
		#21
		やねうら王nano plus V168b
		LMR変更テスト,1スレッド、0.1秒設定
		#1
		やねうら王nano V140
		やねうら王nanoの最終版1スレッド、0.1秒設定

		150-1-20(0.0% R350.0)	

		→　どうも0.5手延長の効果のような気がしてきた。
		ちょっと気分は悪いが、今回のものを採用する。

・Position::capture(),capture_or_promotion()でdrop除外するの忘れていた。修正。
	→　これのためにLMRの処理がおかしくなっていたのか？
	→　これを修正したが、それでもV1.68bにはかなり負け越す。

			30.1%	
			#
			やねうら王nano plus V168c
			LMR変更テスト2,1スレッド、0.1秒設定
			#21
			やねうら王nano plus V168b
			LMR変更テスト,1スレッド、0.1秒設定

			31-1-72(100.0% R-146.4)	

	・V1.68d

		わかった。
          value = depth < ONE_PLY ?
          value = newDepth < ONE_PLY ?



■ 2016/02/21 V1.67

・nano plus、improvingフラグ用意。
	→　この改良は微差のようなのでこのままランニングさせておくる

		50.5%	
		#19
		やねうら王nano plus V167
		improving追加,1スレッド、0.1秒設定
		#0
		やねうら王nano plus V166
		通常探索でevaluate()を呼び出すように,1スレッド、0.1秒設定

		934-3-915(32.9% R3.6)	

		ほぼ変わらない…。なんなの…。


■ 2016/02/21 V1.66

・nano plus、通常探索でeval保存するようにした。
	+R50ぐらいup？
	通常探索でevalが呼び出されると差分計算が出来るようになるのでその分だけ得なのか…。
	やや高速化した気がする。

・Eval::eval()という関数名、気に入らないのでevaluate()と名前を変更する。
・連続対戦のときの戦績が偏るの、同じseedの乱数を使って定跡選択をしているからという話はないか…？
	→　uint64_t(this)を乱数seedにしているので実行ファイルの読み込みのランダム化が行われているなら問題なさげ…。


■ 2016/02/21 V1.65

・まだ落ちる局面があるようだ。もしかして255手目でMAX_PLYに到達して落ちた感じ？

	4<Error : engine timeout , engine name = YaneuraOu nano plus KPP 1.62 64 AVX2
	4< □ 金 □ □ 玉 金 と □ と
	4< □ □ 圭 □ □ 圭 □ 杏 □
	4< □ □ と □ □ □ □ と と
	4< □ □ □ □ □ 馬 □ □ □
	4< □ □ □ □ □ □ □^歩^と
	4< □ □ □ □ □ □ □^と □
	4< □ □ □ □^全 □^と □ □
	4< □ □ □ □^龍^と^玉^と^と
	4< □^金^と □ □ □^と^と^と
	4<先手 手駒 :  歩2 香 角 , 後手 手駒 :  香2 桂2 銀3 飛 金
	4<手番 = 先手
	4<sfen 1G2KG+P1+P/2+N2+N1+L1/2+P4+P+P/5+B3/7p+p/7+p1/4+s1+p2/4+r+pk+p+p/1g+p3+p+p+p b 2PLB2l2n3srg 255

	→　nano plusのsearch stackがkillerの初期化でアクセス違反になるっぽい。
		search<Root>は、やめたほうがいいのでは..うーん。id_loop()、あとで考え直す。
		とりあえずss+1にしてるのはおかしいのでそこだけ修正する。

		あとsearchにMAX_PLYの判定追加する。
		連続王手の千日手、判定していないのでそれ絡みで無限に延長されてPVでMAX_PLYに到達して落ちるのか。そうか…。
		とりあえずMAX_PLYの判定だけ追加した。

	1<Error : engine timeout , engine name = YaneuraOu nano plus KPP 1.64 64 AVX2
	1<^香 □^玉 □ □ □ □ □ と
	1< □ □^龍^金 □ □ □ 馬 □
	1< □ □^桂 □ □ と □ □ □
	1< □ □ □^歩 □ □ □ □ □
	1< □ □ □ □ 歩 □ □ □ □
	1< □ □ 馬 □ □ □ □^歩 □
	1<^と □ □ □ 玉 □ □ □^と
	1< □ □ □ □ □ □ □^と^と
	1< □ □ 龍 □ □ □ □^と □
	1<先手 手駒 :  歩4 桂3 銀 金 , 後手 手駒 :  歩4 香3 銀3 金2
	1<手番 = 先手
	1<sfen l1k5+P/2+rg3+B1/2n2+P3/3p5/4P4/2+B4p1/+p3K3+p/7+p+p/2+R4+p1 b 4P3NSG4p3l3s2g 157

	・前のバージョンに対してだいぶ負けるようになった。もしかして前のバージョン、連続王手の千日手で不利になったときに逃れているパターンがあるのか？

    // 最大手数を超えている
    if (ss->ply >= MAX_PLY)
      return VALUE_ZERO; // Draw Score
	  →　こう変更して引き分けを回避させよう。
	  →　これでもV1.64に-R100ほど負け越している感じ。なんなん…。
	  →　打ち歩詰め絡みで何かやらかしたのか？
	  → recap深さは、やはり-3のほうが良いということなのか..戻した。

・メモリ8GBのときnormal perft、うまく動かないという報告が。
→　固定で確保してるんだった…。


■ 2016/02/21 V1.64

・nano plusで静止探索、深さ-5までCAPTURESを生成しているの、よくない可能性が微レ存。

  // 静止探索でこれより深い(残り探索深さが少ない)ところではRECAPTURESしか生成しない。
  DEPTH_QS_RECAPTURES = -3*(int)ONE_PLY,

  →　1.57aと対戦させておく。こっちのほうが明らかに強いな..

・V1.64a
  
  // 静止探索でこれより深い(残り探索深さが少ない)ところではRECAPTURESしか生成しない。
  DEPTH_QS_RECAPTURES = -2*(int)ONE_PLY,
  →　こう変更するとどうなのだ？
  →　こっちのほうがわずかに強いっぽい。うわぁぁぁ。
  今後、これを基準ソフトにしよう..

		50.7%	
		#16
		やねうら王nano plus V164a
		静止探索のRECAPの深さ-3→-2に変更,1スレッド、0.1秒設定
		#0
		やねうら王nano plus V164
		静止探索のRECAPの深さ-5→-3に変更,1スレッド、0.1秒設定

		1687-16-1638(19.8% R5.1)	


  →　floodgateに放流しておく。


■ 2016/02/21 V1.63

・local server、timeout時にMOVE_RESIGNを返すように変更。
・local server、非合法手もMOVE_RESIGN扱いするように変更。
・そのときにエラーを出力するように変更。
・local server、エンジンを配置するpath変更できるように。
	→　engine-config.txtのほうでエンジン名にpathが指定されていればいいか…。


■ 2016/02/21 V1.62

・打ち歩詰めの処理、LongEffect有り時の高速化
	→　綺麗には書けた気がする。あまり呼び出し頻度の高くない部分のコードなので高速化には寄与していない気が…。

	===========================
	Total time (ms) : 16981
	Nodes searched  : 20291525
	Nodes/second    : 1194954

	1%ぐらいnpsが上がったのか？ちょっと嬉しい。

・nano-plusのデバッグ用のコード消してなかったの修正。


■ 2016/02/21 V1.61

・long effectがあるときにeffected_toは高速化できるのでそのコード追加。

	改良前とbenchのnode数が変わらないことを検証する。
	===========================
	Total time (ms) : 17606
	Nodes searched  : 20291524
	Nodes/second    : 1152534

	→　変更後。nps 0.2%ぐらい上がった？
	===========================
	Total time (ms) : 17578
	Nodes searched  : 20291524
	Nodes/second    : 1154370

	ASSERT無効にしてベンチ

	===========================
	Total time (ms) : 17142
	Nodes searched  : 20291525
	Nodes/second    : 1183731

	何故かノード数が1だけ変わる…。do_move()するようなASSERTどこかに入っているのか..？あとで調べる。

	とりあえずこれでcommitして、floodgateに放流しておく。

・nanoとnano plusと対局させておく。



■ 2016/02/21 V1.60

・pos.legal()の判定おかしいのか。

position startpos moves 7i6h 5c5d 6i7h 3c3d 2g2f 8c8d 7g7f 2b8h+ 7h8h 7a6b 6h7g 3a3b 2f2e 3b3c 4i5h 4a3b 5h6h 4c4d 6h7h 5a4a 5i5h 6a5b 7g8f 7c7d 8f7g 5b4c 5h6i 4a3a B*5b 3a2b 5b6a+ B*9d 6a9d 9c9d B*5b 4c4b 5b6a+ B*4c 6a4c 4b4c 6i5h 6b5c 2e2d 3c2d 7g6f 9d9e 6f6e B*8c 8i7g 6c6d 6e5f 7d7e 7f7e P*7f 7g6e 6d6e 9g9f 9e9f P*2e 2d3c 7e7d 8c7d 9i9f 9a9f P*7e 7d8c B*6c N*8e 8g8f 8e9g+ 8h8g 9g8g 7h8g 9f9g+ 8g7f 8c9d 7f6e P*7f P*9e 9d7b N*9d 7b6c 9d8b+ L*2g 2h2g 5d5e 2g2h G*2g 6e7d
go btime 169000 wtime 29000 byoyomi 10000

	^飛 王 ★

	★の升に移動する指し手はevasionにはならない。
	ゆえにpos.legal()の判定、これを考慮しないといけない。
	effected_to()の仕様がおかしいんだな。修正した。


■ 2016/02/21 V1.59

・local server、応答がなくなる原因わかった。bestmove待ちでエンジンがbestmoveを返さないと
　そのまま待ち状態になるのがいけないのか。1分でtimeoutとしよう。

      // タイムアウトチェック(連続自己対戦で1手に1分以上考えさせない
      if (now() >= start + 60 * 1000)
      {
        sync_cout << "Error : engine timeout" << endl << pos << sync_endl;
        return MOVE_NONE;
      }

・また、local server、一行ずつ出力するのをデフォルトとしよう。
　こちらのほうが、外部から自動操作するときに出力をparseするのが簡単だから。

	// 1行ずつ結果を出力するモード
	#define ONE_LINE_OUTPUT_MODE


■ 2016/02/21 V1.58

・DEPTH_QS_RECAPTURESとりあえず-10にしておく。この値でそんなに悪くはなさそうなので。
→　また後日調整する。


■ 2016/02/20 V1.57b

・local server機能で、プロセスが終了しないとき用の修正。
	→　これでも終了しないことがあるためprocessのkillも行なうようにした。
	→　これでもプロセス残ることがある。おかしい。ソース、読みなおす。
	→　local-serverのidle_loopにsleep(5)を追加。
	→　長手数による引き分け、条件がMAX_PLYになっていたのを256に修正。
	→　こっちの問題ではなさげ..
	→　ソースコード、再度整理する。


・nano-plusのrecaptureの指し手生成間違っていたのを修正。
・nano-plusで静止探索での3手以上延長しないほうがいいのか実験。
      // 探索深さが-3以下ならこれ以上延長しない。
      if (param1)
      {
        if (depth < -3 * ONE_PLY)
        {
          // せっかくevaluateを呼び出したので置換表にhitしていないなら今回のevaluateの値を保存しておく。
          if (!ttHit)
            tte->save(posKey, value_to_tt(bestValue, ss->ply), BOUND_LOWER,
              DEPTH_NONE, MOVE_NONE, ss->staticEval, TT.generation());

          return bestValue;
        }
      }
	  →　なぜかR220ほど下がる。
	  RECAPTURESの指し手生成なにかおかしいのでは..

	  RECAPのフェーズをparam1依存にして、これでパラメーターを変えた実験をしてみる。
	  延々、同じ升でRECAPするだけのはずなのにレーティング下がるのなんで…。

      else if (depth > /*DEPTH_QS_RECAPTURES*/ (Depth)(-3-param1))
        stage = QSEARCH_WITHOUT_CHECKS_START;
		→　MovePickerでttDepth突っ込んでたから延々とCAPTURESが生成されてたくさい。
		→　これ修正したらずいぶんマシになった気がする。ベストな値を探す。


51.8%	56.0%	59.6%	59.8%	64.6%	62.7%	63.9%	
#
やねうら王nano plus V157b
やねうら王nano plus param1!=0なら静止探索で3手以上延長しない,1スレッド、0.1秒設定
#0
やねうら王nano plus V157a
やねうら王nano plus 静止探索のオーダリングいじった,1スレッド、0.1秒設定

489-0-455(12.7% R12.5)	529-0-415(0.0% R42.2)	561-0-381(0.0% R67.2)	536-0-360(0.0% R69.1)	579-0-317(0.0% R104.6)	562-0-334(0.0% R90.4)	470-0-266(0.0% R98.9)	

		↓条件をこう変えてみる

      else if (depth > /*DEPTH_QS_RECAPTURES*/ (Depth)(-7-param1))
        stage = QSEARCH_WITHOUT_CHECKS_START;


70.3%	65.9%	72.1%	64.0%	65.3%	64.1%	60.0%	
#13
やねうら王nano plus V157b
やねうら王nano plus param1に応じて静止探索のrecapまでの手数変更,1スレッド、0.1秒設定
#0
やねうら王nano plus V157a
やねうら王nano plus 静止探索のオーダリングいじった,1スレッド、0.1秒設定

270-0-114(0.0% R149.8)	244-6-126(0.0% R114.8)	253-1-98(0.0% R164.8)	224-2-126(0.0% R100.0)	226-6-120(0.0% R110.0)	223-4-125(0.0% R100.6)	210-2-140(0.0% R70.4)	



■ 2016/02/20 V1.57a

・nano-plusで静止探索の1つ目の深さでは、CAPTURESの指し手を生成するように。(+R180)
・指し手生成に以下の2つを追加
  QUIET_CHECKS,          // 王手となる指し手(歩の不成などは含まない)で、CAPTURESの指し手は含まない指し手
  QUIET_CHECKS_ALL,      // 王手となる指し手(歩の不成なども含む)でCAPTURESの指し手は含まない指し手


■ 2016/02/20 V1.57

・nano-plusで静止探索で置換表のlookupをするように。(棋力にほぼ影響なさげ..)
	→　これnanoのものに戻してもいいぐらいだな..。静止探索絡みはminiに持ち越すか…。

・置換表でdepthが深いと1byteに収まらないのでONE_PLYで割った値を格納するように変更。
・Depthの定数に色々追加。


■ 2016/02/19 V1.56

・nano-plusにLMRを追加。+R150
・静止探索1手詰め + LMRで +R210ぐらいになるはずだが、実際はnanoからはR+145程度のようだ。
おそらく静止探索1手詰めで強くなっているように見えたのが0.5手延長で強くなるように見えるのと同じ現象で、まやかし。

・local-game-serverでmainスレッド以外がエンジン名を設定しているの危ないので修正。


■ 2016/02/19 V1.55

・nano-plusに静止探索でのみ1手詰めを呼び出すようにした。-R20(long effectの更新分)+R70(1手詰めの効果) = +R50(nanoから)


■ 2016/02/19 V1.54c

・nano-plusで静止探索での1手詰め
      {
        // 1手詰み
        Move m;
        if (PvNode && param1)
          m = pos.mate1ply();
        else
          m = MOVE_NONE;
        if (m != MOVE_NONE)
          return mate_in(ss->ply);
      }

・通常探索での一手詰め判定
    Move bestMove = MOVE_NONE;

    // RootNodeでは1手詰め判定、ややこしくなるのでやらない。
    // 置換表にhitしたときも1手詰め判定は行われていると思われるのでこの場合もはしょる
    if (!RootNode && !ttHit && (PvNode && param2))
    {
      bestMove = pos.mate1ply();
      if (bestMove != MOVE_NONE)
      {
        // 1手詰めスコアなので確実にvalue > alphaなはず。
        alpha = mate_in(ss->ply);
        goto TT_SAVE;
      }
    }


50.6%	48.7%	
56.5%	54.2%	
#1
やねうら王nano V140
やねうら王nanoの最終版1スレッド、0.1秒設定
#7
やねうら王nano plus V154c
やねうら王nano plus、1手詰め呼び出し条件の実験,1スレッド、0.1秒設定

2948-0-2876(17.3% R4.3)	2834-0-2990(98.0% R-9.3)	
3292-0-2532(0.0% R45.6)	3101-0-2616(0.0% R29.5)	

静止探索では無条件で1手詰めを呼ぶのがよさげ。
自己対戦だと0.5手延長みたくなって、勝率が上がっているだけかも知れないが。

・1.54d

    // RootNodeでは1手詰め判定、ややこしくなるのでやらない。
    // 置換表にhitしたときも1手詰め判定は行われていると思われるのでこの場合もはしょる
    if (!RootNode && !ttHit & param1)
    {
      bestMove = pos.mate1ply();
      if (bestMove != MOVE_NONE)
      {
        // 1手詰めスコアなので確実にvalue > alphaなはず。
        alpha = mate_in(ss->ply);
        goto TT_SAVE;
      }
    }


	42.0%	54.4%	
	#1
	やねうら王nano V140
	やねうら王nanoの最終版1スレッド、0.1秒設定
	#8
	やねうら王nano plus V154d
	やねうら王nano plus、通常探索で1手詰め呼び出すか,1スレッド、0.1秒設定

	1397-0-1931(100.0% R-56.2)	1710-0-1432(0.0% R30.8)	

	→　呼び出さないほうが強いようだ。




■ 2016/02/18 V1.54

・local server、結果を1行ずつ出力するモード用意。
・local server、finish時に子プロセスのエンジン開放するためにquitコマンドを送信するように変更。
・nano-plusでの実験用にoptionとしてParam1,Param2追加。


■ 2016/02/18 V1.53

・mate1で漏れているケースがあったので修正。
sfen p2g3n1/2gn4g/+P1s1k3s/1ppr2+Lbp/1P1p1K2b/4P1Ppl/3+n1P1RP/LS3p1PL/3P+p2NS w Ppg 160

test rp
Random Player test , loop_max = 100000000
mate found = 10000 , mate miss = 746 , mate found rate  = 93.0579%
mate found = 20000 , mate miss = 1460 , mate found rate  = 93.1966%
mate found = 30000 , mate miss = 2181 , mate found rate  = 93.2227%
mate found = 40000 , mate miss = 2939 , mate found rate  = 93.1554%
mate found = 50000 , mate miss = 3759 , mate found rate  = 93.0077%
mate found = 60000 , mate miss = 4617 , mate found rate  = 92.8548%
mate found = 70000 , mate miss = 5387 , mate found rate  = 92.8542%
mate found = 80000 , mate miss = 6204 , mate found rate  = 92.8031%
mate found = 90000 , mate miss = 6882 , mate found rate  = 92.8965%
mate found = 100000 , mate miss = 7561 , mate found rate  = 92.9705%
mate found = 110000 , mate miss = 8327 , mate found rate  = 92.9627%

→　0.2%ほど詰み発見率が上がった。


■ 2016/02/18 V1.52

Position.cppで評価関数を使わないときに
	#ifndef EVAL_NO_USE
で囲み忘れていたところがあったので修正。


■ 2016/02/11 V1.51

・コマンドライン引数の複数コマンドの実行機能を追加。fileからの実行機能も追加。


■ 2016/02/10 V1.50

・自己対局サーバー、1スレッド×同時対局(マルチスレッド)に対応させる。goコマンドがThreads数を反映するように。
	→　マルチスレッド化した。


■ 2016/02/09 V1.49

・スレッドまわり改修して、協力詰めエンジンがコンパイル通らなくなっていたの修正。

	MainThread::searchがvirtualなので単にsearchって書くとthink()が呼び出されてしまうので注意。
	次のように書く必要がある。

	void MainThread::think() {
	  for (auto th : Threads.slaves) th->start_searching();
	  Thread::search();
	  for (auto th : Threads.slaves) th->wait_for_search_finished();
	}
	void Thread::search() { HelpMate::id_loop(rootPos, (int)thread_id(), (int)Options["Threads"]); }


■ 2016/02/09 V1.48

・Threadまわり全面的に書き直す。
	→　大改修したら落ちなくなった。やはりそうだったのか…。
	→　スレッドまわりがすっきりして気分がいい。

・nanoとminiとビルドしなおしてローカル自己対局。
	→　直ってる気がする。そうか。スレッドまわりだったのか…。

・自己対局のときにコマンドラインではなくファイルから開始コマンドを受け取りたいのでusi.cppを改良。
	引数で指定されたものを連結して一つのコマンドとして実行する機能があればいいのか…そうか。

	次のような.batファイルを作ってそれを実行すれば連続自己対局が簡単に開始できる。
	> local-game-server.exe go btime 500

・解説.txtの説明が古かったので刷新。

・スレッドまわり大改修したのでexeフォルダのnanoのバイナリ差し替え。

・shogi.hからマクロ関係をextra/macros.hに移動。


■ 2016/02/09 V1.47

・あかん。__mm_mallocが失敗する状況において、newも失敗する。これランタイムおかしいのでは…。
	revertする。

・Releaseビルド時のランタイムなら落ちない。Debugビルド時のnewでまわり、高負荷時にかち合うと失敗するのでは。

	main threadのnewをするタイミングが早すぎてランタイムの初期化が終わっていないことがあるのでは…。
	→　main threadのnewは、ThreadPool::init()のなかが最初。これは、main関数のなかのThreads.init()から
	呼び出される。ということは、問題なさげ。

	そもそも、sizeof(MainThread)==1312しかないのに。

    // Tの基底クラスはstd::threadなのでスライシングされて正しく代入されるはず。
    *th = std::thread([&] {((T*)th)->idle_loop(); });
    // →どうもMSVCのデバッグ用ランタイム、これやるとatomic_boolとかの実装と相まってまずいようだ。


■ 2016/02/09 V1.46

・自動対局サーバー、ときどき3つ目ぐらいのインスタンス走らへん。原因調査。
	・自己対局サーバーに子プロセスとの通信ログ出力機能追加。

・Position::material、EVAL_NO_USEのときに参照している箇所があったのでifdefで囲んだ。

・デバッガで再現しない。また、local game server自体が落ちることがある。原因調査。
	→　どうも負荷状態において _mm_malloc()が失敗して未初期化のポインターが返ってきているような感じなのだが…。
	→　ランタイムが何か共有してて、同時起動時において初期化がされないのではないかな。MSVC、ひどい実装だな。
		マルチスレッドデバッグDLLに何かバグがある予感。
	→　VSからCtrl+F5連打でこの現象が起きる。
	→　_mm_malloc()自前で実装する。


// --------------------
//  __mm_malloc(),__mm_free()
// --------------------

// MSVCの__mm_malloc(),__mm_free()が高負荷状態において失敗するので自前で用意。
// 速度的には遅いがそんなに急所でこの関数を呼び出すわけではないので構わない。

// size = 要求メモリ量(byte単位)、align_size = アライメントするサイズ
inline void* my_mm_malloc(size_t size, size_t align_size)
{
  const auto ptr_alloc = sizeof(void*); // この分余分に確保して[-1]のところに元のポインターを保存しておく。
  size_t request_size = size + align_size;
  const auto needed = ptr_alloc + request_size;
  auto alloc = ::operator new(needed);
  void* alloc2 = (uint8_t*)alloc + ptr_alloc;
  auto ptr = std::align(align_size, size, alloc2, request_size);
  ((void**)ptr)[-1] = alloc;
  return ptr;
}

inline void my_mm_free(void* ptr)
{
  if (ptr)
  {
    void* alloc = ((void**)ptr)[-1];
    ::operator delete(alloc);
  }
}


■ 2016/02/09 V1.45

・1手詰め見つけたときにスコアおかしいな。
	mate distance pruning入れないと駄目なのか
	→　入れたらなおった..よしよし。

・nano plusにnode stackを導入する。

・nanoとnano plusでbenchでの探索node数が合致するようにする。

	nano
	===========================
	Total time (ms) : 13332
	Nodes searched  : 13282757
	Nodes/second    : 996306

	nano plus、1手詰めなし、mate distance pruningなし。
	===========================
	Total time (ms) : 11896
	Nodes searched  : 10584735
	Nodes/second    : 889772

	→　合致しない。ソース比較する。
	MovePickerが原因としか考えられない。うわー。

	MovePicker nanoにものと差し替えたらnode数合致した。
	===========================
	Total time (ms) : 14328
	Nodes searched  : 13282757
	Nodes/second    : 927048
	LONG_EFFECTの更新で7%ぐらい遅くなってるのか..これで利きを使わない評価関数だとだいぶ損だな。

	ああ、MovePicker、ttMoveと先頭のをswapするのでオーダリング違うのか。そうか。

	===========================
	Total time (ms) : 11129
	Nodes searched  : 10584735
	Nodes/second    : 951094
	LONG_EFFECT更新なしにして7%ぐらい上がった。
	MovePickerで段階生成にしてるので4%ほど損してるのか。
	いまの状況だとほぼall nodeになるので仕方ないか。

・nano plusにkiller move実装したら枝刈り性能あがった気がする。

	===========================
	Total time (ms) : 3863
	Nodes searched  : 4850357
	Nodes/second    : 1255593

	bench d 時のdepth上げる。

	===========================
	Total time (ms) : 12855
	Nodes searched  : 13773887
	Nodes/second    : 1071480

・nanoと対局させる。
	nano VS nano plus
	62-0-38
	46-1-53
	48-0-52
	166-3-131
	161-4-135
	---------
	483/892=0.54

	killerで枝刈り効率が上がっているはずだが、LONG_EFFECTの更新の7%と
	MovePickerの逐次化による5%ほどとが回収できてないのか…。大変だな。


■ 2016/02/09 V1.44

・benchコマンド追加。
・MAX_DEPTH、設計良くないな。削除。
・これに伴い、nano,nano plusのid_loop、修正。
・benchコマンド完成。
	→　nano plusのベンチマーク、異常に悪い件。
	===========================
	Total time (ms) : 14419
	Nodes searched  : 11172282
	Nodes/second    : 774830
・比較用にnanoもベンチが通るように修正する。
	nano plusへの修正をbackport

	nanoのほう
	===========================
	Total time (ms) : 13476
	Nodes searched  : 13282757
	Nodes/second    : 985660

・nano/nano plusのconfigure、testコマンド、デフォルト有効にしておく。
・nano plus ASSERTなしでbench
	===========================
	Total time (ms) : 12411
	Nodes searched  : 11172282
	Nodes/second    : 900191

	めっちゃ変わった。どのASSERTがそんなに重いというのか..わからん。
	MATE1外してみる。

	===========================
	Total time (ms) : 12257
	Nodes searched  : 10584735
	Nodes/second    : 863566

	探索木変わったのでむしろ増えた。

	mate1外してnanoと探索ノード数が同じでないの、おかしい。あとで原因調べる。
	mate1、non PVでも有効にして、ASSERTなしにして、nanoと対戦させておく。

	non PVでもmate1入れるとnps増えた。mate1で枝刈りされて無駄な指し手生成が端折られたからか？
	===========================
	Total time (ms) : 5016
	Nodes searched  : 5955513
	Nodes/second    : 1187303

	nano-nano plus
	112-4-84
	103-3-94
	107-0-93
	少しの負け越しで済んだが、やはり何かおかしいな。
	benchの探索node数が同じにならないのはバグだろうから、調査する。


■ 2016/02/08 V1.43

・nano plusのMovePickerで段階的な指し手生成を実装。
	→　やってみたがnpsほぼほぼ上がってない。(気がする。)
	mate1入れたせいもあるのか。

・1手詰め、うまく詰ませられない。
position startpos moves 1g1f 8c8d 7g7f 8d8e 8h7g 7a6b 6g6f 5a4b 2h8h 5c5d 7i7h 4b3b 3i3h 6b5c 5i4h 3c3d 3g3f 5c4d 7h6g 5d5e 4g4f 6a5b 6i5h 7c7d 5h4g 9c9d 1f1e 2b3c 2i3g 8a7c 4h3i 9d9e 3i2h 3c4b 2g2f 8b8d 6f6e 7c6e 7g6f 8d8a 5g5f 5e5f 6g5f 6c6d 4f4e 4d3c P*5d 5b6c 5f5e 3b2b 3g2e 4a3b 3f3e 3d3e 8h5h 8e8f 5e4f 8f8g+ 2e3c 4b3c 6f3c+ 3b3c 5h5i P*5g B*7b 8a8f 7b6c+ 8g7g 6c6d 8f8h+ 6d6e 7g6h 5i5g 8h8i N*2e 3c3b 6e5e N*3c P*3d N*4b 4f3e 8i7i 5d5c+ B*7h 3d3c+ 2a3c 2e3c+ 3b3c N*2e P*3b 5c4c N*3d 4c3c 3b3c 2e3c+ 2b2a G*2b 3a2b
go btime 0 wtime 0 byoyomi 30000000
→　修正した。

・nano-nono plus
	59-1-40
	60-1-39
	47-2-51
	55-5-40
	0.56

枝刈りが甘い状況ではmate1にそんなに価値がないのかも。
PV nodeでだけ呼び出すか。
→　1手詰め判定は通常探索、静止探索ともにPV nodeのみに変更。
もう寝るのでこの条件で2000回対戦させておく。
	318-4-178
	315-11-174
	332-5-163
	330-8-162
	---------
	1295-28-677
	0.656
	めっちゃ負けてる。おかしい。差分取る。
	→　mate1は軽いのでnon PVでも入れたほうがいいということか。
	→　MovePickerで遅くなった分、回収できていないのか。
	→  bench書く。

・自動対戦サーバー、ときどき3つ目ぐらいのインスタンス走らへん。あとで原因調べる。


■ 2016/02/08 V1.42

・nano plus、1手詰め判定追加。
	87-4-109  R35ほどup？大したことないな。枝刈りが甘いからmate見つけてもリターンが小さいんだな。

・config.h、デフォルトではdefineしないことに。
・add_hand(),sub_hand()、inlineにしていると内部コンパイルエラーになるときがあるのでshogi.cppのほうで定義するように変更。
・Depth自体は32bitでいいのでは..


■ 2016/02/08 V1.41

・materialの計算もifndef EVAL_NO_USE内に分離
・clangでコンパイルが通るように。
	http://llvm.org/releases/download.html
	> Download LLVM 3.7.1
	> Clang for Windows (64-bit) (.sig)
	LLVM-3.7.1でコンパイルが通るように頑張る。
	→ ClangだとAVX関係が色々難しいみたい。gccならいけそうだが…。
	gccでコンパイル通すのはまた今度にする。

・これコメントアウト

/*
// 静止探索時の最大探索深さ
const int MAX_QUIET_PLY = 6;

// 通常探索時の最大手数である128に、静止探索時の最大深さを加えた定数。
// 局面バッファ(StateInfo)などは、すべてこのサイズで確保する。
const int MAX_SEARCH_PLY = MAX_PLY + MAX_QUIET_PLY;
*/

・DEPTH_MAXが必要なので修正。


■ 2016/02/08 V1.40

・実行ファイルを配布するにあたって、定跡ファイルを移動させて、評価関数バイナリの置き場を変更する。
	将来的に評価関数バイナリを切り替えられるようにする。また、将来的に定跡を複数から選択可能にする。

	eval/kpp16ap.bin
	eval/kkp32ap.bin
	book/standard_book.db
	→ exe/YaneuraOu-nano-readme.txtに詳しく書いた。

・やねうら王nano plusの開発開始。
	engine/nano-plus-engine追加。


■ 2016/02/07 V1.39

・やねうら王nanoの探索部、少し改良
	→　nonPV用の処理を少し書く。
	→　そこそこうまく書けた気がする。floodgateに投入しておく。
	これでR2000ぐらいになっているならnanoの開発はこれにて終了。


■ 2016/02/07 V1.38

・差分計算時のテスト
isready
position startpos moves 7g7f 8b3b 5i6h 5a6b 2g2f 6b7b 2f2e 3c3d 3i4h 3d3e 8h2b+ 3a2b 2e2d 2c2d 7i7h 5c5d 7h7g 2b2c B*6f B*2b 6f2b+ 3b2b 6h7h 2c3d 4g4f 2d2e 4h4g 2e2f B*6f B*3c 6f3c+ 2a3c 4i3h B*4i B*5f 3d2e 4g5h 4i5h+ 6i5h S*5e B*1e 4a3b 5f4g 5e4f 4g5f 5d5e
go btime 10000000
info depth 8 score cp -1502 nodes 16874114 nps 1063204 hashfull 420 time 15871 pv 5f6e 1c1d 1e3c+ 3b3c 3g3f B*4i 5h6h 2e3f
// 差分計算なし。
info depth 8 score cp -1502 nodes 16874114 nps 896414 hashfull 420 time 18824 pv 5f6e 1c1d 1e3c+ 3b3c 3g3f B*4i 5h6h 2e3f
17%ぐらいnps up!!
計算合った。これで良し。

・EVAL_KPP、差分計算、実装完了。
・read_book()、デバッグ中だったの戻した。
・DirtyPiece型導入。
・StateInfoからkingSquare除く。


■ 2016/02/07 V1.37

・Eval::compute_eval()で全計算して初期化する。
・差分で遡るの1局面前までに限定する。

・差分計算デバッグ中。
・README.md、整形


■ 2016/02/07 V1.36

・KPP評価関数の差分計算まわり。

・StateInfoにdirtyPiece追加。
・Eval/evaluate_kpp分離
・Eval/evaluate_bona_piece分離
・shogi.hのほうに
	int hand_count(Hand hand, Piece pr) { ASSERT_LV2(PIECE_HAND_ZERO <= pr && pr < PIECE_HAND_NB); return (hand >> PIECE_BITS[pr]) & PIECE_BIT_MASK[pr]; }
	int hand_exists(Hand hand, Piece pr) { ASSERT_LV2(PIECE_HAND_ZERO <= pr && pr < PIECE_HAND_NB); return hand & PIECE_BIT_MASK2[pr]; }
を書くと内部コンパイルエラーになるのでshogi.cppのほうに移動。
・EVAL_KPPのevaluateに差分計算追加。
・kingSquare、StateInfoに移動させる。


■ 2016/02/06 V1.35

・nanoのid_loopまわり、ちょっと整理した。


■ 2016/02/06 V1.34

・定跡DBの読み書き、std::mapではなくstd::unorder_mapを使うように変更。


■ 2016/02/05 V1.33

・定跡ファイルに定跡フォーマットのバージョン識別文字列を追加。


■ 2016/02/05 V1.32

・定跡にその指し手が採択された回数の項目を追加。
・nanoで定跡の指し手に関して、採択確率を出力するようにした。(将棋所ではこれでうまく表示される)


■ 2016/02/05 V1.31

・extra/book.hとcpp追加。
・test_cmd.cppから移動。
・bookの読み込み、書き込み等の操作を細かくして追加。
・read_all_lines()でエラーのときに1を返すように。
・nanoの定跡にbook.dbを用いるように変更した。


■ 2016/02/05 V1.30

・定跡部、何かフレームワークからのサポートを考える。
→　考えた。解説に書いた。nano以外ではこれを使うことにする。
・read_all_lines()、空行はskipするように。
・makebookコマンド、sfen→db変換実装した。
・doc/nano-book.db削除。
・doc/book.db追加。


■ 2016/02/05 V1.29

・nanoの秒読み時の使用時間、もう少し少なくしないとtime upになるので修正。
・USIオプションに"NetworkDelay"追加。
・YaneuraOuMini_ja.txt → YaneuraOu_ja.txtにリネーム
　バイナリは全部YaneuraOu.exeでいいや。


■ 2016/02/04 V1.28

・nano、floodgateに放流している人を見るとR1700ぐらいらしい。もう少しチューンする。
・nanoの静止探索で王手がかかっているならalpha = -VALUE_INFINITEにして、
	あと静止探索の延長は3手までにする。
	→　少し強くなった気が。

・nanoの静止探索の指し手生成、RECAPTURESからCAPTURES_PRO_PLUSに変更してみる。
	→　弱くなった。
・Position::is_ok()にcheckesの検証を追加。
・CAPTURES_PRO_PLUSで歩の成りに自駒のある場所を除外していなかったのを修正。

position startpos moves 2g2f 3c3d 7g7f 8c8d 2f2e 1c1d 2e2d 2c2d 2h2d
go btime 169000 wtime 17100000 byoyomi 0

・検証用のコード
      for (auto p = currentMoves; p != endMoves; ++p)
        if (!pos.pseudo_legal(*p))
        {
          cout << pos << *p;
          for (auto m : MoveList<CAPTURES_PRO_PLUS>(pos))
            cout << m.move << " ";
        }

・nanoに定跡追加。
　　→　序盤、少しだけマシになった。

・misc.h/cppにread_all_lines()追加。
・プロジェクトのdoc/nano-book.sfen追加。

・対局中おかしかった局面のテスト
position startpos moves 7g7f 8b3b 5i6h 5a6b 2g2f 6b7b 2f2e 3c3d 3i4h 3d3e 8h2b+ 3a2b 2e2d 2c2d 7i7h 5c5d 7h7g 2b2c B*6f B*2b 6f2b+ 3b2b 6h7h 2c3d 4g4f 2d2e 4h4g 2e2f B*6f B*3c 6f3c+ 2a3c 4i3h B*4i B*5f 3d2e 4g5h 4i5h+ 6i5h S*5e B*1e 4a3b 5f4g 5e4f 4g5f 5d5e
go btime 10000000

・nanoの通常探索の指し手生成、CAPTURESさきに生成すると枝刈り性能が上がるはず。→　少し強くなった。

・あと探索の並列化と評価関数の差分更新をやるとR200ぐらい上がるかも。

・2016年1月の作業メモから完了分

【完了】・1手詰め判定ルーチン、影の利きを考慮した詰み
【完成】・1手詰め判定ルーチン、打ちと移動による簡単な詰み
【完成】・undo_move()で利きの差分更新処理(戻す処理)、実装完了。ランダムプレイヤーによる自動テストをpassした。
【完成】・do_move()での利きの差分更新処理が正しいかをランダムプレイヤーによる自動テストにより確認。
【完成】・Position::do_move()のときのcaptureとnon_captureのときの利きの差分更新処理
【完成】・Position::do_move()のdropのときの利きの差分更新処理
【完成】・Long Effect Library
【完成】・利きの初期化処理
【完成】・自動対局サーバーの開始局面のランダマイズ機能
【完成】・自動対局サーバー機能、書けた。
【完成】・32bit環境用のコード、ちゃんと動くようになった。(手元に32bit環境がないので実際の環境で試してはいない。)


■ 2016/02/01 V1.27

・mate1plyで漏れているケースをいくつか修正。
sfen 1nk3G2/l4+RGb1/s1p5l/n2p3pp/1p1PP4/4KPPP1/NPP1S3P/LR3ppGL/B2+p+n1S2 b 2PSG 123
→詰むようになった。0.1%ほど詰み発見率が上がった。

sfen +P1+Lg1S+P1b/+P2k4p/1N1l1+R2n/1LG1Gp2L/S5p2/1PPP1g1p1/B3R3n/pp2+n1KsP/1S4P2 b 2P2p 203
→詰むようにした。0.2%ほど詰み発見率が上がった。

・USI拡張コマンドとして"mate1"コマンド追加。

test rp
Random Player test , loop_max = 100000000
mate found = 10000 , mate miss = 793 , mate found rate  = 92.6526%
mate found = 20000 , mate miss = 1524 , mate found rate  = 92.9195%
mate found = 30000 , mate miss = 2257 , mate found rate  = 93.0031%
mate found = 40000 , mate miss = 3035 , mate found rate  = 92.9476%
mate found = 50000 , mate miss = 3877 , mate found rate  = 92.804%
mate found = 60000 , mate miss = 4764 , mate found rate  = 92.6441%
mate found = 70000 , mate miss = 5544 , mate found rate  = 92.6612%
mate found = 80000 , mate miss = 6376 , mate found rate  = 92.6183%
mate found = 90000 , mate miss = 7079 , mate found rate  = 92.708%
mate found = 100000 , mate miss = 7795 , mate found rate  = 92.7687%
mate found = 110000 , mate miss = 8561 , mate found rate  = 92.7792%
mate found = 120000 , mate miss = 9318 , mate found rate  = 92.7945%


■ 2016/02/01 V1.26

・static const排除。実行ファイルのサイズが20KBほど縮んだ。
　悪い影響はなさそうなのでこれでいく。
・Recaptureの指し手生成器、作る。
・movegenの指し手生成、選択式のするのやめる。どうせ呼び出していなければリンカーで削除される。
・NON_EVASIONS_ALL追加。
　→　呼びださなければ実行ファイル、1バイトも増えない。よしよし。
・nanoの静止探索、RECAPTURESを使って書き換え。


■ 2016/01/31 V1.25

・nanoの静止探索、standPatと比較するの忘れてた。修正。
→　修正したら少し強くなった感。


■ 2016/01/31 V1.24

・評価値、局面の差分更新をしたときにおかしくなるので、駒番号まわりのテストコード追加する。
→　難しい。書きにくい。
・BonaPieceの文字列での出力関数実装
・evalstatにPieceListの内容を表示、追加。
・test rpコマンドのランダムプレイヤーに評価値の差分計算のチェック機構追加。
・undo_move()で駒番号おかしくなっていたの修正。
・mateのときの手数表示がおかしいの修正。


■ 2016/01/31 V1.23

・nanoのデバッグ進める。
・USI::score_to_usi()追加
・USI::pv()追加。
・評価関数の値がおかしい気がしなくもない。
・sfenコマンド追加。(以前のものを変更)


■ 2016/01/31 V1.22

・nanoにはsee使わない。
・nanoの静止探索書く。
・nanoにid_loop導入。
・TanspositionTableにvalue_to_tt()とか追加する。
・goコマンドのデフォルトを秒読み1秒にしておく。(テストしにくいので)
・USI::Optionのコンストラクタで、on_changeのイベントハンドラを呼び出すように変更。
	→　この設計だと駄目なのか。仕方ないので置換表のコンストラクタでデフォルト16MB確保する。
・USI::pv()追加。読み筋表示用。


■ 2016/01/30 V1.21

・Position::sse()追加。
・extra/see.cpp追加。
・USE_SEE追加。


■ 2016/01/29 V1.20

・評価関数、旧バージョンと値の比較。
・EvalList::set_piece修正。

position sfen lnsgkgsnl/1r5b1/pppppppp1/9/9/2P5p/PP1PPPPP1/LB5R1/1NSGKGSNL w p 8


■ 2016/01/27 V1.19

・やねうら王nanoとminiの探索部書いていく。
・評価関数のimportしてくるところから。
　→　だいたい出来た気がする
・put_pieceで落ちる。
  → 王手がかかっているのにEVASIONS呼び出さなかったからか。
> position startpos moves 3i4h 3c3d
> position startpos moves 7g7f 3c3d 8h2b
evalおかしい。何これ。


■ 2016/01/27 V1.18

・Bitobardのoperator == () がまさかの高速化。これ、そもそもほとんど使ってないのであまり変わらんが…。


■ 2016/01/25 V1.17

・ByteBoard、WordBoard、無理やり取ってくるなら端にpaddingしといたほうが無難か…。

■ 2016/01/24 V1.16

・1手詰めに影の利きを考慮した詰みも追加。
・1手詰めで漏れているケースもう少し追加する。
・uint8_t -> u8とかtypedefする
・24近傍の9近傍への長い利きを回収するコード追加。
・mate1plyの移動による詰みをlambdaに変更。
・1手詰め判定で影の利き考慮するようにした。

test rp
Random Player test , loop_max = 100000000
mate found = 10000 , mate miss = 827 , mate found rate  = 92.3617%
mate found = 20000 , mate miss = 1590 , mate found rate  = 92.6355%
mate found = 30000 , mate miss = 2354 , mate found rate  = 92.7242%
mate found = 40000 , mate miss = 3190 , mate found rate  = 92.614%
mate found = 50000 , mate miss = 4072 , mate found rate  = 92.4693%
mate found = 60000 , mate miss = 5015 , mate found rate  = 92.2864%
mate found = 70000 , mate miss = 5822 , mate found rate  = 92.3215%
mate found = 80000 , mate miss = 6704 , mate found rate  = 92.2679%
mate found = 90000 , mate miss = 7435 , mate found rate  = 92.3693%
mate found = 100000 , mate miss = 8202 , mate found rate  = 92.4197%
mate found = 110000 , mate miss = 8984 , mate found rate  = 92.4494%

詰み率 92%ちょいぐらいになった。8%ぐらいが影の利きありでの1手詰めなのか。

ランダムプレイヤーで数時間まわしておく。
→　1.6億局面をpassしたのでうまく動いてるやろ…。


■ 2016/01/23 V1.15

・dirs_bw_of()→long_effect_ofとリネーム
・mate1plyの判定率、ランダムプレイヤーで計測できるようにした。

Random Player test , loop_max = 100000000
mate found = 10000 , mate miss = 28848 , mate found rate  = 25.7414%
mate found = 20000 , mate miss = 58089 , mate found rate  = 25.6118%
mate found = 30000 , mate miss = 87252 , mate found rate  = 25.5859%
mate found = 40000 , mate miss = 116252 , mate found rate  = 25.5997%
mate found = 50000 , mate miss = 146594 , mate found rate  = 25.4331%
mate found = 60000 , mate miss = 176384 , mate found rate  = 25.3824%
mate found = 70000 , mate miss = 206668 , mate found rate  = 25.3011%
mate found = 80000 , mate miss = 237090 , mate found rate  = 25.2294%
→　おかしい。低すぎ。

・移動による詰み、駒打ち用のdirectionsテーブルではまずいのか…。修正した。

test rp
Random Player test , loop_max = 100000000
mate found = 10000 , mate miss = 1590 , mate found rate  = 86.2813%
mate found = 20000 , mate miss = 3134 , mate found rate  = 86.4528%
mate found = 30000 , mate miss = 4722 , mate found rate  = 86.4006%
mate found = 40000 , mate miss = 6296 , mate found rate  = 86.4006%
mate found = 50000 , mate miss = 7953 , mate found rate  = 86.2768%
mate found = 60000 , mate miss = 9620 , mate found rate  = 86.1821%
mate found = 70000 , mate miss = 11028 , mate found rate  = 86.3899%
mate found = 80000 , mate miss = 12651 , mate found rate  = 86.3455%
mate found = 90000 , mate miss = 14175 , mate found rate  = 86.3931%
mate found = 100000 , mate miss = 15725 , mate found rate  = 86.4118%
→　だいぶ上がった。もう少し上がって欲しい気が。



■ 2016/01/23 V1.14

・do_move()に関するベンチが要るな。
	test rpbenchコマンド追加。書けた。4600 games/sec程度。
	1局が大抵256手まで行くことを考えると256×4600回の指し手生成 + do_move()/undo_move()だから妥当なところ？
	ASSERT、long_effectオフにしたら6327 gps
	long_effectだけオフにしたら5909gps
	ASSERTだけオフにしたら4959 gps。
	・ASSERTで5%ほど低下。long_effectは探索部と評価関数がなしだとすると30%ぐらい低下ということなのかな。
・Effect8に各駒の利き追加する
・1手詰め作っていく。
・UnitTestにMate1Ply関連のテストコード追加。
・HAND_KIND_ZERO追加。
・PRO_GOLD→QUEENに変更してeffects_fromにQUEEN追加。
・effects_fromにNO_PIECEのときの処理追加。
・駒打ちによる1手詰め判定できるようになった。
・桂の移動による1手詰め判定できるようになった。
・銀の移動による1手詰め判定うまく動いた。
・ランダムプレイヤーで1手詰め判定の自動テストするコードを追加。
・pseudo_legal()で金の成る手のチェックが抜けていたのを修正。
・1手詰めでの大駒による長い利きの遮断修正。
・1手詰めで桂打ちで利きを遮断するケース考慮。
・ランダムプレイヤーでランニング。動いているようだ。


■ 2016/01/22 V1.13

・undo_move()で戻す処理に利きを戻す処理も書くことにする。たぶん、そんなに遅くないはずで…。
・undo_move()も先後分けた。
・LongEffectLibraryに利きの更新の逆変換関数追加。
・ランダムプレイヤーで利きのrevertのテスト。
　このまましばらくランニングさせておく。
・関数の名前revertでなくrewindにしよう。
・Position::set_effect、LongEffect::に移動。


■ 2016/01/22 V1.12

・captureとnon_captureのときの利きの更新処理追加。
　→　これで利きの更新処理は一通り書けた。あとは…
・ランダムプレイヤーによる利きの更新の自動テスト追加。
・UNREACHABLE、ASSERT_LV3に変更。
・undo_moveで利きを巻き戻す作業がいるのか..これは難しい..
・LSB32/64にASSERT_LV3追加。
・利きのdo_move()での更新はこれで問題なさげ。undo_move()をどうするか考え中。


■ 2016/01/22 V1.11

・長い利き、WordBoardでないとまずいのか…。書き直し。
・make_piece()引数の順番変更。Colorをつねに先に。
・ENABLE_BIT_OPERATORS_ONに operator &= などを追加。
・WordBoardの表示修正。
・利きの初期化部、マクロいくつか削除。
・LongEffect::dir_bw_of()追加。
・Directionsのenumに定数追加。
・Position::do_move()のdropのときの利きの更新処理書けた。
　あとはcaptureとnon_captureのときの利きの更新処理！


■ 2016/01/21 V1.10

・has_long_effect()追加。
・↑をUnitTestに追加。
・UPDATE_EFFECT_BY_PUTTING_PIECE、マクロ化した。(利きの差分更新のところでも使うため。)
・LONG_EFFECTにINCもDECも要らんかった。一つにまとめた。
・Direction削除。Effect8のものを持ってきて、これを使うことにする。
・SQWW_RIGHT→SQWW_Rとかにリネーム。
・Position::do_move()を内部的に、先後分ける。
・pop_lsb(uint8_t)追加。
・pop_directionsの引数変更。
・ENABLE_BIT_OPERATORS_ON追加。
・Directionsにbegin(),end()追加。
→　あかん。よくなかった。削除。
・pop_lsb()をbitop.hに移動。templateで書くことにした。


■ 2016/01/20 V1.09

・Effect8::directions_of()追加。
・長い利きの初期化コード書けた。→　正しそう。
・ByteBoardの出力関数書いた。
・MAX_PLY_ → MAX_PLY_NUMにリネーム。
・LONG_EFFECT→LONG_EFFECT_LIBRARYにリネーム。
・long_effect.h/cpp、ifdef LONG_EFFECT_LIBRARYで囲った。


■ 2016/01/19 V1.08

・user.cpp、わかりにくいのでuser-engine.cppにリネーム。
・Positionクラスに利きを持たせる。
・利きの初期化コードおよび差分更新コードを追加する。
・Position::set_effect()書いた。
・評価関数、shogi.hで選択可能にする。(まずは準備だけ)
・config.h、書式整えた。


■ 2016/01/19 V1.07

・SquareWithWall追加。これを使って利き関係の初期化処理を書き直す。
・dist、これがあれば不要？ → 不要ではなかった。
・LongEffectライブラリにSquareWithWallの差分値追加。


■ 2016/01/19 V1.06

・aligned_stack、内部的にvectorを使うように変更。


■ 2016/01/19 V1.05

・std::stack<StateInfo>を用いるときにpush()に対して内部的にstackがStateInfoをnewするのだが
　これがalignmentされてなくてまずいのか…。そんな問題があるのか…。
→　StateInfoにcustom new/delete追加。

  // custom allocator(このクラスはstd::stack<StateInfo>のpush()によって内部的にnewされるが、そのときに
  // alignasが無視されるので、custom allocatorが必要になる…ようだ。)
  static void* operator new (std::size_t count){ return _mm_malloc(count,alignof(StateInfo));  }
  static void operator delete(void* p) { _mm_free(p); }

→　これでも駄目なのか。難しい…。

// C++11では、std::stack<StateInfo>がalignasを無視するために、代わりにstack相当のものを自作。
template <typename T> struct aligned_stack {
  void push(const T& t) { auto ptr = (T*)_mm_malloc(sizeof(T), alignof(T)); *ptr = t; container.push(ptr); }
  T& top() const { return *container.top(); }
  ~aligned_stack() { while (container.size()) { auto ptr = container.top(); _mm_free(ptr); container.pop(); } }
private:
  std::stack<T*> container;
};
こうしてみた。


■ 2016/01/19 V1.04

・engine/mate-engine/ 追加。このあとコードを書いていく。


■ 2016/01/19 V1.03

・自動対局フレームワークの開始局面をランダマイズする機能追加。
 →　定跡を読み込めるようにした。


■ 2016/01/19 V1.02

・move_from_usi()に合法チェック追加。
・連続自動対局フレームワーク、一通り動くようになった。
 →　対局開始局面のrandomize出来たほうがいいので何か考える。


■ 2016/01/18 V1.01

・連続自己対戦サーバー用のProcessNegotiatorで入出力のリダイレクトは出来るようになった。
　あとはこれを非同期入出力にして連続自己対局が出来るようにすればOk.


■ 2016/01/18 V1.00

・連続自己対戦サーバー機能追加作業開始。
	engine/local-game-server
・"Version"がwindows.hの内部の文字列と衝突した。"ENGINE_VERSION"にリネーム。
・_mm_malloc()～_mm_free()を使うように変更。


■ 2016/01/18 V0.99

・bitop.hとkey128.hのコメント掃除。


■ 2016/01/18 V0.98

・128bit hash keyを用いるときにalignmentが合ってないエラーがでうるのを修正。


■ 2016/01/18 V0.97

・x86で正常動作するようになった。指し手生成とか半分ぐらいの速度しか出ないが…。
・aligned_allocをbitop.hに移動させた。


■ 2016/01/18 V0.96

・size_t、x86環境だと32bitなのか…。ランダムプレイヤー修正。
・ランダムプレイヤー、GitHubにpushするの忘れてたので追加。


■ 2016/01/18 V0.95

・x86用のコード、allocatorだけ追加しておく。
・USE_AVX2をコメントアウトしたときにコンパイルが通らなくなっていたの修正。


■ 2016/01/18 V0.94

・Stockfishの升の差分を表現するDELTA_Nとか読みにくくてカナワンので、SQ_UPとかに変更。


■ 2016/01/18 V0.93

・engine関係、ひとつのフォルダにまとめる
・ランダムプレイヤーをengineとして追加。
・とりあえず、ビルドのデフォルトをランダムプレイヤーにしておく。(やねうら王miniの探索部が書けたらそれをデフォルトに変更する)
・StateInfo,Positionクラスのアライメントの調整をしたせいか、指し手生成が少し速くなったようだ。指し手生成祭りの局面で5.4M回/s程度(Core i7 4771にて)
・PRNGクラス、少しメンバー追加した。


■ 2016/01/18 V0.92

・x86用にコード修正。コンパイルは通るようになったが、Bitboardの代入等で落ちる。(アライメント合ってないから？)
コンパイル時に、こんな警告。
> source\thread.cpp(15): warning C4316: 'MainThread': ヒープで割り当てられたオブジェクトが 16 にアラインメントされていない可能性があります
	→　thread.cppのnewしているところでaligned_new<T>()みたいなものが必要っぽいのだが、これを修正しても
　ランタイムで落ちるようだ。よくわからんので誰か助けて欲しい…。
・よく考えるとKey256を使う場合も_mm256_store_si256()が32byteでアライメントされていることを要求するから、
	これと同じ問題があるのか…。誰も使ってないだろうからそっちはまあいいか…。

■ 2016/01/17 V0.91

・x86用のemulation code、各種追加。

■ 2016/01/17 V0.90

・GitHubにて公開。

