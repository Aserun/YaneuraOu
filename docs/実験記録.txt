

■　2016/06/20

] V3.11

      // 評価関数を呼び出したので置換表のエントリーはなかったことだし、何はともあれそれを保存しておく。
+      // tte->save(posKey, VALUE_NONE, BOUND_NONE, DEPTH_NONE, MOVE_NONE, ss->staticEval, TT.generation());
+      // →　どうせ毎node評価関数を呼び出すので、evalの値にそんなに価値はないからこれをやめる。


	Core i7 4771k
	===========================
	Total time (ms) : 150870
	Nodes searched  : 92242005
	Nodes/second    : 611400


		秒読み1000[ms]

		59.5%	
		#210
		やねうら王2016mid V311
		新基準。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		94-5-64(0.7% R66.8)	


		秒読み3000[ms]

		41.4%	
		#210
		やねうら王2016mid V311
		新基準。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		96-10-136(99.7% R-60.5)	


	V3.11a
	historyでdropの+32をやめると？

		-      pc = Piece(pos.piece_on(sq) + (is_drop(move) ? 32 : 0));     \
		+      pc = Piece(pos.piece_on(sq) );     \

  Piece moved_piece_after_ex(Move m) const {
    return is_drop(m)
-      ? Piece(move_dropped_piece(m) + (sideToMove == WHITE ? PIECE_WHITE : NO_PIECE) + 32)
+      ? Piece(move_dropped_piece(m) + (sideToMove == WHITE ? PIECE_WHITE : NO_PIECE) /*+ 32*/)
      : is_promote(m) ? Piece(piece_on(move_from(m)) + PIECE_PROMOTE) : piece_on(move_from(m));
  }

-        Piece prevPc = pos.piece_on(prevSq) + Piece(is_drop((ss - 1)->currentMove) ? 32 : 0);
+       Piece prevPc = pos.piece_on(prevSq);


  これで互角なら、この処理なくしたい。
  Moveに移動させる駒が入っていれば、親nodeの移動させる駒が得られて、移動前の駒種でhistoryが
  引けて便利なのかも知れない。(cf. Apery)
  そこで強さに差が出ないなら、そのほうがシンプル。

		秒読み1000[ms]

		48.6%	
		#211
		やねうら王2016mid V311a
		history駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		297-13-314(76.7% R-9.7)	

	誤差ぐらい。ここでわずかに良くとも、CPU cache汚染とかの問題があるので
	誤差ぐらいしか変わらないなら採用したくないのだが…。

		秒読み3000[ms]

		49.7%	
		#211
		やねうら王2016mid V311a
		history駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		292-17-295(56.6% R-1.8)	

	ほぼ誤差だな。これは削除すべきか。そうか。

		  // 直前のnodeの指し手で動かした駒(移動後の駒)とその移動先の升を返す。
		  // この実装においてmoved_piece()は使えない。これは現在のPosition::side_to_move()の駒が返るからである。
		  // 駒打ちのときは、駒打ちの駒(+32した駒)が返る。
		#define sq_pc_from_move(sq,pc,move)                                \
			{                                                              \
			  sq = move_to(move);                                          \
			  pc = Piece(pos.piece_on(sq);     \
			}

	V3.11b
	ソースコード整理して、やねうら王2016 MidではUSE_DROPBIT_IN_STATSを使わないようにした。
	以前のバージョンより弱くなっていないかをテスト。

	history、移動前の駒で評価しても棋力変わらないのかも。
	指し手生成のときにmoveの上位bitを移動後の駒にするのは難しくはないのだが。
	というか、成りはquietではないのでhistoryからそもそも除外されているのか？
	除外は歩の成りだけか。うーん。角とか飛車の成り、本当に除外していいのか？
	価値上昇値が、歩の成りよりは低いか。	

		秒読み3000[ms]

		42.5%	
		#212
		やねうら王2016mid V311b
		history駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		110-3-149(99.4% R-52.7)	

	あれ？めっちゃ弱くなった。どうなってんの…。

      // 評価関数を呼び出したので置換表のエントリーはなかったことだし、何はともあれそれを保存しておく。
      // tte->save(posKey, VALUE_NONE, BOUND_NONE, DEPTH_NONE, MOVE_NONE, ss->staticEval, TT.generation());
      // →　どうせ毎node評価関数を呼び出すので、evalの値にそんなに価値はないからこれをやめる。

	この省略が得していない？
	ああ、mate1ply()、置換表にhitしたときに省略されるのか。その差だな。
	修正して、再テスト。

		秒読み3000[ms]

		45.5%	
		#212
		やねうら王2016mid V311b
		history駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		222-21-266(97.9% R-31.4)	

	やはり悪いのか…。そうなのか…。
	これは戻さざるをえない。

	V3.11c元に戻して0.3秒テスト。
	間違えてた。

		#ifndef USE_DROPBIT_IN_STATS   
			  pos.piece_on(prevSq);
		#else
			  pos.piece_on(prevSq) + Piece(is_drop((ss-1)->currentMove) ? 32 : 0);
		#endif

	こうだった。
	→　これで3.11と互角に戻った。再実験。

	V3.11d
		秒読み300[ms]

		48.3%	
		#214
		やねうら王2016mid V311d
		historyから駒打ち削除。1スレッド
		#210
		やねうら王2016mid V311
		新基準。1スレッド

		703-21-752(90.1% R-11.7)	
	
	短い時間ではCPU cacheの汚染が少ないので勝ち越さなければならないのに
	勝っていないので、これは本当にダメそう。

	V3.11e
	MovePicker、killerの数に応じて、QUIET0,1,2,3とか分岐してはダメか？そこそこ意味があるような？

	> bench 1024 1 11

		===========================
		Total time (ms) : 5338
		Nodes searched  : 3102160
		Nodes/second    : 581146


	KPPTは、ehash実装したほうが速いのかも。



■　2016/06/18

] PGO

・PGOかける

	Visual Studio Community 2015でK-Shogiをビルドしてみた
	http://blog.studiok-i.net/shogi/1272.html

		「デバッグ」メニュー ⇒ 「XXXのプロパティ」を選択 ※XXXはプロジェクト名
		「全般」 – 「プログラム全体の最適化」に「ガイド付き最適化のプロファイル – インストルメント」を選択
		リビルドする
		「デバッグ」メニュー ⇒ 「デバッグの開始」
		適当に動かす（最適化してほしいところを集中的に動かすとよい）
		「デバッグ」メニュー ⇒ 「XXXのプロパティ」を選択
		「全般」 – 「プログラム全体の最適化」に「ガイド付き最適化のプロファイル – 最適化」を選択
		ビルドする（リビルドではない）

	PGO前
	===========================
	Total time (ms) : 126895
	Nodes searched  : 79320741
	Nodes/second    : 625089

	PGO後
	===========================
	Total time (ms) : 124923
	Nodes searched  : 79320741
	Nodes/second    : 634957

	1%ほどしか変わらない。おかしい…。仮想環境だからな..

] V3.10

	・5,10秒で魔女と対戦

	5秒→10秒で勝率が低下する。長い持ち時間になったときに勝率が低下するファクターが
	まだ何か残っているのだと思う。静止探索での一手詰めとかあのへん怪しい。
	assert復活させてPGOなしにしてもう少し実験せねば。

		秒読み5000[ms]
		38.8%	
		#192
		やねうら王2016mid V310
		利きなしsmate/qmate PGO。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		85-7-134(100.0% R-79.1)	


		秒読み10000[ms]
		32.9%	
		#192
		やねうら王2016mid V310
		利きなしsmate/qmate PGO。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		199-28-406(100.0% R-123.9)	

	利き更新なし＋1手詰めなしにしたときの10秒での勝率とほぼ変わらない。
	静止探索での1手詰めが長い持ち時間において足を引っ張っている気がする。
	しかし、静止探索のオーバーヘッドだけでそんなに勝率が変わるとは考えにくいので
	他の要因があるはず。

	5秒対戦だとnpsの差で負けている可能性とかもあって、原因がよくわからない。
	10秒対戦での勝率を見ながらチューンするしかない。

		
	短い時間では静止探索での1手詰めの効果は顕著なのだが…。

		秒読み100[ms]

		43.9%	
		#193
		やねうら王2016mid V310a
		利きなしsmate。1スレッド
		#192
		やねうら王2016mid V310
		利きなしsmate/qmate PGO。1スレッド

		723-24-923(100.0% R-42.4)	



	静止探索での1手詰めを入れないと弱くなった。
	やはり意味があるように思える。

		秒読み10000[ms]

		27.0%	
		#193
		やねうら王2016mid V310a
		利きなしsmate。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		31-1-84(100.0% R-173.2)	


	まさかと思うがONE_PLY = 1で試す。
	そうか。futility margin、ONE_PLYで割られていないのでONE_PLY = 2でやっていると
	半分の値でやっていることになるのか…そうか…。
	ならStockfishのfutility margin = 200は100相当なので、わりといまの値に近いのか…。


		秒読み100[ms]

		45.1%	
		#194
		やねうら王2016mid V310b
		ONE_PLY=1。1スレッド
		#192
		やねうら王2016mid V310
		利きなしsmate/qmate PGO。1スレッド

		352-13-429(99.7% R-34.4)	

	少し弱くなった。ONE_PLYの値に影響を受けている何かがあるのか…。
	PGOの差かも知れない。reduction table絡みかも知れない。

		秒読み500[ms]

		49.8%	
		#194
		やねうら王2016mid V310b
		ONE_PLY=1。1スレッド
		#192
		やねうら王2016mid V310
		利きなしsmate/qmate PGO。1スレッド

		138-1-139(54.8% R-1.3)	

	500[ms]だとほぼ変わらずっぽいのでONE_PLY=1のままちょっといろいろいじる。

	V3.10c
	reduction量を変えてみる。

		  for (int imp = 0; imp <= 1; ++imp)
			for (int d = 1; d < 64; ++d)
			  for (int mc = 1; mc < 64; ++mc)
			  {
				double r = log(d) * log(mc) / 2;
				if (r < 0.80)
				  continue;

				reduction_table[NonPV][imp][d][mc] = int(std::round(r)) * ONE_PLY;
				reduction_table[PV][imp][d][mc] = std::max(reduction_table[NonPV][imp][d][mc] - ONE_PLY, DEPTH_ZERO);

				if (!imp && reduction_table[NonPV][imp][d][mc] >= 2 * ONE_PLY)
				  reduction_table[NonPV][imp][d][mc] += ONE_PLY;
			  }

	ONE_PLY = 1と2の差は関係なくて、reductionテーブルは後者のほうが理想に近いのが、
	長時間において差が出る要因なのだろう…。ONE_PLY = 2のほうが各種パラメーターを
	調整しやすいので良いはずなのだが、現状、そこまで細かく調整する価値のあるパラメーターが
	なくて、ONE_PLYで割るコストのほうが高くついているのかも知れない。

		秒読み500[ms]

		49.1%	
		#195
		やねうら王2016mid V310c
		ONE_PLY=1,reduction変更。1スレッド
		#193
		やねうら王2016mid V310a
		利きなしsmate。1スレッド

		276-8-286(67.9% R-6.2)	

	ほぼ互角。3秒でも変わらなければこちらを採用したほうが良いのでは…。


		秒読み3000[ms]
		59.1%	
		#195
		やねうら王2016mid V310c
		ONE_PLY=1,reduction変更。1スレッド
		#193
		やねうら王2016mid V310a
		利きなしsmate。1スレッド

		65-3-45(2.2% R63.9)	

	どうも長い時間では新しいreduction tableのほうが有利くさい。(もう少しやったほうが良い)
	長い時間で魔女と勝率に差があく原因の一つはこれなのか？

	魔女と5秒でやらせてみる。


		秒読み5000[ms]

		31.1%	
		#195
		やねうら王2016mid V310c
		ONE_PLY=1,reduction変更。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		66-9-146(100.0% R-137.9)	

	前よりたくさん負け越した。そんな馬鹿な…。
	この際、魔女に近づけて行って、勝率どこで回復するか見たほうが良いのでは..

	V3.10d
	LMR新テーブル + qsearchでのmateなしとのコンボ。
	
		秒読み5000[ms]

		31.7%	
		#196
		やねうら王2016mid V310d
		ONE_PLY=1,reduction変更,qmateなし。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		33-2-71(100.0% R-133.1)	

	よく見たら魔女もqsearchでmate1呼んでた。置換表に書き出していないが…。

	V3.10e
	qmate復活。qmateのタイミングをもう少し早めに変更。
	mate1を見つけたときに置換表に書き出す処理、やめる。

		秒読み5000[ms]

		29.4%	
		#197
		やねうら王2016mid V310e
		qmate復活。呼び出しタイミング調整。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		55-5-132(100.0% R-152.1)	

	どんどん弱くなっててワロタ。


	V3.10f
	aspirationの幅40->18,深さ7->5

		秒読み5000[ms]

		34.4%	
		#198
		やねうら王2016mid V310f
		aspiration幅変更。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		77-8-147(100.0% R-112.3)	

	aspirationまわり変えたら、少し強くなった。
	そうか。Apery向けのaspirationではないので少し損をしていたのか…。

	Aperyのコード以下の部分、fall throughなのか。怖すぎワロタ。
		switch (pos.isDraw(16)) {
		case NotRepetition      : if (!Signals.stop.load(std::memory_order_relaxed) && ss->ply <= MaxPly) { break; }
		case RepetitionDraw     : return ScoreDraw;

	V3.10g
	update_stats()するの、capture or pawn promotionであるべき。

	V3.10h
	すべて↑であるべき。


		秒読み5000[ms]

		36.4%	
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		68-2-119(100.0% R-97.2)	

	R15ぐらい違うのかな？

		秒読み10000[ms]

		34.7%	
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		114-14-215(100.0% R-110.2)	

	10秒でもそんなにRは下がらなくなってきた。よしよし。


	USE_DROPBIT_IN_STATS、もしかして無駄である可能性…。
	まあいいや。いまそこが問題ではない。

	あとどこだろ。

	・指し手生成で何か抜けている可能性
	→　quiet + capture = all になるかとかテストすべき。

	・SEE()がおかしい可能性
	→　簡単な探索部と合致するかテストすべき

	・新しく書いたmate1ply()がおかしい可能性
	・評価関数が重い可能性
	
	V3.10i
	利き有効にしてのmate1ply()

		秒読み1000[ms]

		49.4%	
		#201
		やねうら王2016mid V310i
		利き使ったmate1ply()。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		170-6-174(60.6% R-4.0)	


		秒読み3000[ms]

		42.0%	
		#201
		やねうら王2016mid V310i
		利き使ったmate1ply()。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		42-4-58(95.6% R-56.1)	

	はやり遅い分だけやや損なのかも。

	see()書きなおしてみるか。

	V3.10j
	USE_SIMPLE_SEEを用意した。

		bench
		===========================
		Total time (ms) : 442722
		Nodes searched  : 308535061
		Nodes/second    : 696904

	だいぶ速くなった気がする。
	SEE、もう少し速くできる気がする。

		秒読み1000[ms]

		6.7%	
		#202
		やねうら王2016mid V310j
		simple see()。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		2-0-28(100.0% R-458.5)	

	20連敗した。SEE、これじゃない感。

	turn間違えてる。
	  Color turn = ~(is_drop(move) ? sideToMove : color_of(piece_on(move_from(move))));
	いま、seeの順番、金があとになってるのよくない気はする。
	あと、攻撃の有無間違えてた。あれだけでこんなに勝率下がるのか。そうか…。

		秒読み100[ms]

		22.7%	
		#202
		やねうら王2016mid V310j
		simple see()。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		20-0-68(100.0% R-212.6)	

	めっちゃ弱くなっとる。よく調べる。
	see()の前提処理まちごてた。修正した。

	see()前のコードも最後KING+1を返しているの、これおかしい気がしてきた。そうか…。
	と金で何かを取るとき、これがKING扱いになっていたのか。修正した。

		===========================
		Total time (ms) : 189502
		Nodes searched  : 108434227
		Nodes/second    : 572206

	
		秒読み300[ms]

		39.3%	
		#202
		やねうら王2016mid V310j
		simple see()。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		132-5-204(100.0% R-75.6)	

	新SEE、バグってるんやろか。元のSEEに戻してテスト。

	V3.10k

		秒読み300[ms]

		49.8%	
		#203
		やねうら王2016mid V310k
		see() fix。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		311-10-313(54.8% R-1.1)	

	SEE直したはずなのだが、勝率に影響がない。そんなもんなのか…。
	
	min_attacker()さらになおした。orderingも改善したはず…だが？

	V3.10l

		// 歩、香、桂、銀、金、角、飛…の順で取るのに使う駒を調べる。

		Bitboard b;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_PAWN  ][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_LANCE ][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_KNIGHT][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_SILVER][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_GOLD  ][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_BISHOP][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_ROOK  ][stm]; if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_HDK][stm] & ~(pos.piece_bb[PIECE_TYPE_BITBOARD_ROOK  ][stm] | pos.king_square(stm)); if (b) goto found;
		b = stmAttackers & pos.piece_bb[PIECE_TYPE_BITBOARD_HDK][stm] & ~(pos.piece_bb[PIECE_TYPE_BITBOARD_BISHOP][stm] | pos.king_square(stm)); if (b) goto found;

		// ここでサイクルは停止するのだ。
	#ifndef USE_SIMPLE_SEE
		uncapValue = VALUE_ZERO;
	#endif
		return KING;

	わりとわかりやすい気がする。


		秒読み300[ms]

		48.7%	
		#204
		やねうら王2016mid V310l
		see() fix。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		364-13-383(76.8% R-8.8)	

	わずかに遅くなった分、回収できていないのか…？

	// この駒が成れるなら、成りの値を返すべき。
	// ※　最後にこの地点に残る駒を返すべきなのか。相手が取る/取らないを選択するので。
	Piece pt = type_of(pos.piece_on(sq));
	if (!(pt & PIECE_PROMOTE) && (pt != GOLD)
		&& (canPromote(stm, to) || canPromote(stm,sq)))
		// 成りは敵陣へと、敵陣からの二種類あるので…。
	{

#ifndef USE_SIMPLE_SEE
		uncapValue = ProDiffPieceValue[pt]; // この駒が取り返せなかったときこの分、最後に損をする。
#endif
		return pt;
	}

	→　ちゃんと書いた。

		秒読み300[ms]

		50.0%	
		#204
		やねうら王2016mid V310l
		see() fix。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		525-19-524(48.8% R0.3)	

	やっと前のものと等価ぐらいになった。

	新see()なおってたりしないのか。
	V3.10m

		秒読み300[ms]

		41.8%	
		#205
		やねうら王2016mid V310m
		see() fix。1スレッド
		#200
		やねうら王2016mid V310h
		update_stats()呼び出し修正。1スレッド

		147-5-205(99.9% R-57.8)	

	落ちなくはなったが弱い。まだ何かバグがある模様。
	まあいいや。これはまた時間あるときにデバッグしよう。
	
	V3.10n
	futility margin = 200など

		秒読み3000[ms]

		42.1%	
		#206
		やねうら王2016mid V310n
		see() fix。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		174-12-239(99.9% R-55.1)	

	差が縮まってきた…？

	V3.10o

	// 捕獲から逃れる指し手はreduction量を減らす。
	→　これ意味不明だった。どういうトリックかよくわからない。
	これ、コメントアウトしたほうがよさげ。
	see()の仕様がこちらの想定と違うのだが、それを考慮しても、
	Stockfishのコードはバグっているとしか思えない。

	null moveのreduction等を戻す。

		秒読み3000[ms]

		41.8%	
		#207
		やねうら王2016mid V310o
		see() fix。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		46-2-64(96.5% R-57.4)	


	V3.10p

-        pv[0] = MOVE_NONE;
+        (ss+1)->pv[0] = MOVE_NONE;

	なんぞこれ。間違えてた。

	魔女、fail lowたときに直前の指し手にボーナスを与える条件、間違っているような…。
		else if (depth >= 3 * OnePly
		  && bestMove.isNone() //!bestMove
		  && !inCheck
-		  && !ttMove.isCapture()//!move.cap()
+		  && !pos.captured_piece_type()
		  && (ss-1)->currentMove.is_ok())

	historyのupdateで打ち駒を+32してないところがあった。修正した。
	
	魔女より15%ぐらい遅いのかも知れない。(R40相当？)
	評価関数の差分計算とMoveの構造体、考えなおしたほうがよさ気。

		秒読み3000[ms]

		43.9%	
		#208
		やねうら王2016mid V310p
		see() fix。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		47-5-60(91.2% R-42.4)	

	npsの差程度に落ち着いてきた？寝る前に10秒で回しておく。
	せっかくなのでfutilityの幅を変える実験でもしておく。

	V3.10q
		  Value futility_margin(Depth d, int game_ply) {
			return Value(d * (PARAM_FUTILITY_MARGIN_ALPHA + param1 * 10 - 20) / ONE_PLY);
		  }

	Move32bit化、bit layout考えなおしたほうがよさ気。
	移動させる駒、上位16bitに格納するなら、駒打ちをそのbit5に格納したほうがいいような。
	historyで打ち駒を本当に分けたほうがいいのかはよくわからないが。
	historyにおいて、移動させる元の駒でorderingすべきなのか、そのあとの駒でorderingすべきか。
	指し手生成のときにそこまで生成すべきかどうか悩むな。


		秒読み10000[ms]

		41.1%	37.2%	37.5%	36.3%	39.6%	
		#209
		やねうら王2016mid V310q
		futility実験。1スレッド
		#0
		silent_majority_V1.1公式
		1スレッド

		129-18-185(99.9% R-62.6)	110-16-186(100.0% R-91.2)	112-13-187(100.0% R-89.0)	110-9-193(100.0% R-97.7)	120-9-183(100.0% R-73.3)	

	futility margin 180にしておくか。

